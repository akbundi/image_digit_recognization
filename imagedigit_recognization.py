# -*- coding: utf-8 -*-
"""Untitled93.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yZbNzzVk_BtmcSJz-Z0Cci4rlu2v5KD4
"""

import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
import torchvision.datasets as datasets
from torch.utils.data import DataLoader
from PIL import Image, ImageOps
import numpy as np
import os

# Device Configuration
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Define CNN Model
class CNNModel(nn.Module):
    def __init__(self):
        super(CNNModel, self).__init__()
        self.conv1 = nn.Conv2d(1, 32, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1)
        self.fc1 = nn.Linear(64 * 7 * 7, 128)
        self.fc2 = nn.Linear(128, 10)

    def forward(self, x):
        x = torch.relu(self.conv1(x))
        x = torch.max_pool2d(x, 2)
        x = torch.relu(self.conv2(x))
        x = torch.max_pool2d(x, 2)
        x = x.view(-1, 64 * 7 * 7)  # Flatten
        x = torch.relu(self.fc1(x))
        x = self.fc2(x)
        return x

# Train Model if Not Exists
try:
    model = CNNModel().to(device)
    model.load_state_dict(torch.load("digit_model.pth"))
    model.eval()
except FileNotFoundError:
    print("Training new model as 'digit_model.pth' was not found.")
    model = CNNModel().to(device)
    optimizer = optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.CrossEntropyLoss()
    train_dataset = datasets.MNIST(root='./data', train=True, transform=transforms.Compose([transforms.ToTensor()]), download=True)
    train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)

    for epoch in range(5):  # Train for 5 epochs
        for images, labels in train_loader:
            images, labels = images.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(images)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()

    torch.save(model.state_dict(), "digit_model.pth")
    print("Model trained and saved as 'digit_model.pth'")

# Preprocessing Function
def preprocess_image(image_path):
    image = Image.open(image_path).convert("L")  # Convert to grayscale
    image = ImageOps.invert(image)  # Invert colors
    image = image.point(lambda x: 0 if x < 128 else 255)  # Binarization

    img_array = np.array(image)
    digit_images = []

    for i in range(img_array.shape[1]):  # Scan columns
        column = img_array[:, i]
        if column.min() == 0:  # Found black pixels
            start = i
            while i < img_array.shape[1] and img_array[:, i].min() == 0:
                i += 1
            end = i
            digit = image.crop((start, 0, end, image.height))  # Crop digit
            digit = digit.resize((28, 28))  # Resize to 28x28
            digit = transforms.ToTensor()(digit).unsqueeze(0).to(device)  # Convert to tensor
            digit_images.append(digit)

    return digit_images

# Recognize Digits
def recognize_digits(image_path):
    digits = preprocess_image(image_path)
    result = ""

    with torch.no_grad():
        for digit in digits:
            output = model(digit)
            predicted = torch.argmax(output, 1).item()
            result += str(predicted)

    return result


# Upload Image via CMD without Providing Path
if __name__ == "__main__":
    os.system("explorer .")  # Open File Explorer to let user select an image
    image_name = input("Enter the name of the image file (present in the current directory): ")
    image_path = os.path.join(os.getcwd(), image_name)

    if os.path.exists(image_path):
        recognized_number = recognize_digits(image_path)
        print("Recognized Digits:", recognized_number)
    else:
        print("File not found in the current directory.")